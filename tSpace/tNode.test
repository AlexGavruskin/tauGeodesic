package tTree;
/*
 * Node class, contains an arraylist of taxa included and a double height;
 * This is code to the part of the tNode class with the current methods for the testing of speeds:
 *	Different speeds being tested are given in 'modifiedSpeedTree' method
 *NOTE: Test is not generalised for trees of more than 4 taxa.  
 * Currently the 2 cherry path seems to be shorter majority of the time, however there are cases where regular caterpillar path is better
 * Also shortest path may be partially determined by which node (1,2) or (1,2,3,4) intersects node(1,2,3) first.
*/
import java.util.*;
import java.io.*;
//Consider making the time of tree another part of tNode;

//I think findTimes has the answers for both case0 and case1 together.

public class tNode {
	ArrayList<String> taxa;
	double height;
	
	public tNode(ArrayList<String> taxa, double height){
		this.taxa = taxa;
		this.height = height;		
	}
	
	public void setHeight(double height){
		this.height = height;
	}
	public double getHeight(){
		return height;
	}
	public void setTaxa(ArrayList<String> taxa){
		this.taxa = taxa;
	}
	public ArrayList<String> getTaxa(){
		return taxa;
	}
	public String toString(){
		StringBuilder sb = new StringBuilder();
		sb.append(taxa);
		sb.append(height);
		return sb.toString();
	}
	
	//Generate takes taxa, heights of taxa, etc.
	public static double generate(String[] taxa1, double[] height1,String[] taxa2, double[] height2, double time, 
			boolean iterate,boolean distances,boolean absSpeed, String filename, int t1Move, int t2Move, int t3Move){
		ArrayList<tNode> tree1 = new ArrayList<tNode>();
		ArrayList<tNode> tree2 = new ArrayList<tNode>();		
		//perhaps start with check if taxa and height are of equal length and also that taxa1 and taxa2 are equal length;
		//also check how many taxa. -  need at least 2;
		for(int i = 0; i<taxa1.length; i++){
			ArrayList<String> s1 = new ArrayList<String>();
			ArrayList<String> s2 = new ArrayList<String>();
			s1.add(taxa1[i]);
			s2.add(taxa2[i]);			
			tNode node1 = new tNode(s1, height1[i]);
			tNode node2 = new tNode(s2, height2[i]);
			tree1.add(node1);
			tree2.add(node2);			
		}
		//cat0 --> regular caterpillar path
		//cherry --> path in which 2 cherries occur
		if(distances){
			double cat0 = findAllTimesOfIntersection(tree1, tree2, absSpeed);
			double cherry = findTheWay(tree1, tree2, t1Move, t2Move, t3Move, false);
			if(cat0 > cherry){
				System.out.println("Double Cherry PathWay is quicker!");
			} else {
				System.out.println("Regular Caterpillar is quicker!");
			}
		}
		
		//otherPathway(tree1, tree2);
		return findTheWay(tree1, tree2, t1Move, t2Move, t3Move, distances);
	}


//calls modifiedSpeedTree for each topology change
	//Assumes the 4 taxa tree where (1,2),(1,2,3),(1,2,3,4) -->  (3,4),(3,4,1),(3,4,1,2)
	//I use ints and cases for the possible speeds of nodes
		//find intersection;
	//get values at that point in time, and find distance between t1 and tnext;
	//set tree1 to tree at that time, 
	//find next intersection until time:1
	public static double findAllTimesOfIntersection(ArrayList<tNode> tree1, ArrayList<tNode> tree2, boolean absSpeed){
		ArrayList<Double> allTimes = new ArrayList<Double>();
		double totalDistance = 0;
		allTimes = findTimes(tree1, tree2, allTimes, absSpeed, totalDistance);
		allTimes.add(0.0);		
		double totalTime = 0.0;
		ArrayList<Double> allTimes2 = new ArrayList<Double>();
		ArrayList<Double> allTimes3 = new ArrayList<Double>();
		allTimes3.add(0.0);
		for(int i = allTimes.size()-1; i >= 0; i--){
			allTimes2.add(allTimes.get(i));				
		}
		//here, calculate totalDistance which will be returned for path length comparison
		ArrayList<tNode> treeNext = tree1;
		
		for(double t : allTimes2){
			treeNext = mergeSort(treeNext);
			ArrayList<tNode> speed = speedTree(treeNext, tree2, false);
			ArrayList<tNode> treeNext2 = getTreeAtTime(treeNext, speed, t);
			System.out.println("TreeNext2: " + treeNext2);
			System.out.println(findTheDistance(treeNext, treeNext2));
			totalDistance += findTheDistance(treeNext, treeNext2);
			treeNext = treeNext2;
		}
		System.out.println("This: " + totalDistance);
		
		System.out.println(allTimes2);
		for(int i = 1; i < allTimes2.size(); i++){
			double t1 = allTimes2.get(i);
			totalTime = t1 * (1.0 - totalTime) + totalTime;
			System.out.println(totalTime);
			allTimes3.add(totalTime);			
		}	
		return totalDistance;
	}	
	public static ArrayList<Double> findTimes(ArrayList<tNode> tree1, ArrayList<tNode> tree2,
			ArrayList<Double> allTimes, boolean absSpeed, double totalDistance){	
			tree1 = mergeSort(tree1);		
			ArrayList<tNode> speedTree = speedTree(tree1, tree2, absSpeed);
			ArrayList<tNode> tree2Ordered = new ArrayList<tNode>();
			for(int i=0; i<tree1.size(); i++){
				double h = tree1.get(i).getHeight() + speedTree.get(i).getHeight();
				tree2Ordered.add(new tNode(tree1.get(i).getTaxa(), h));
			}			
			ArrayList<tNode> timeSwapTree = timeSwapTree(tree1, tree2Ordered);
			//perhaps timeSwapTree method should just produce the minTime - since that's all we use it for.
			double minTime = 3.0;
			for(int i = 0 ; i<timeSwapTree.size(); i++){
				double nextTime = timeSwapTree.get(i).getHeight();
				if(nextTime < minTime && nextTime > 0.0){
					minTime = timeSwapTree.get(i).getHeight();
				}
			}
			//System.out.println("MinTime:  " +  minTime);			
			if(minTime == 1.0){
				allTimes = findTimes(tree1, tree2, allTimes,false, totalDistance);
			}
			else if(minTime > 1.0){
				allTimes.add(1.0);
				double dist = findTheDistance(tree1, tree2);
				totalDistance += dist;
				//System.out.println(dist);
				System.out.println("TD: " +totalDistance);
				return allTimes;
			} 	else {			
			ArrayList<tNode> treeNext = getTreeAtTime(tree1, speedTree, minTime);
			System.out.println("TreeNext: " + treeNext);
			double dist = findTheDistance(tree1, treeNext);
			totalDistance += dist;
			///System.out.println(dist);
			//System.out.println("TD: " +totalDistance);
			allTimes = findTimes(treeNext, tree2, allTimes, absSpeed, totalDistance);
			allTimes.add(minTime);		
			}
			
		return allTimes;
	}
	public static double findTheDistance(ArrayList<tNode> tree1, ArrayList<tNode> tree2){
		double distance = 0;		
		for(int i = 1; i<tree1.size(); i++){ //note if i go back change this to int i =1;
			double dist = (tree1.get(i).getHeight() - tree2.get(i).getHeight());	
			distance += (dist*dist);
		}
		return Math.sqrt(distance);
	}
	
	public static double findDistance(ArrayList<tNode> tree1, ArrayList<tNode> tree2){
		double distance = 0;		
		for(int i = 0; i<tree1.size(); i++){ //note if i go back change this to int i =1;
			double dist = (tree1.get(i).getHeight() - tree2.get(i).getHeight());	
			distance += (dist*dist);
		}
		return Math.sqrt(distance);
	}
		
	public static ArrayList<tNode> getTreeAtTime(ArrayList<tNode> tree, ArrayList<tNode> speedTree, double time){
		ArrayList<tNode> treeNext = new ArrayList<tNode>();		
		for(int i=0; i<tree.size(); i++){
			double heightnext = tree.get(i).getHeight() + speedTree.get(i).getHeight()*time;
			treeNext.add(new tNode(tree.get(i).getTaxa(), heightnext ));
		}
		return treeNext;
	}
	//calls modifiedSpeedTree for each topology change
	//Assumes the 4 taxa tree where (1,2),(1,2,3),(1,2,3,4) -->  (3,4),(3,4,1),(3,4,1,2)
	//I use ints and cases for the possible speeds of nodes
	//output --> determines if the path is outputed or not.
	public static double findTheWay(ArrayList<tNode> tree1, ArrayList<tNode> tree2, int t1Move, int t2Move, int t3Move, boolean output){
		
		double distance = 0.0;
		double dist = 0.0;
		tree1 = mergeSort(tree1);
		tree2 = mergeSort(tree2);
		tree1 = generateProperTree(tree1);
		tree2 = generateProperTree(tree2);
		tree2 = reorderTree2(tree2);  //boths trees now go:  t1, t2, t3	
		
		ArrayList<tNode> speedTree = modifiedSpeedTree(tree1, tree2, t1Move, t2Move, 5, null);		
		ArrayList<tNode> tree2Mod = tree2Mod(tree1, speedTree);
		
		ArrayList<tNode> timeSwapTree = timeSwapTree(tree1, tree2Mod); 		
		double minTime = findMinTime(timeSwapTree);
		if(minTime == 1.0){
			return 100000;
		}
		ArrayList<tNode> treeStage2 = modifiedGetTreeAtTime(tree1, speedTree, minTime);		
		dist  = findDistance(tree1, treeStage2);		
		distance += dist;
		if(output){
			System.out.println();
			System.out.println("The choice of the speeds " + t1Move + " , " + t2Move + " , " + t3Move + " result in the following: ");
			System.out.println("Tree1:		" + tree1);	
			System.out.println("Speed Tree:	" + speedTree);
			System.out.println("Tree to reach:	" + tree2Mod);
			System.out.println("Tree End stage 1:" + treeStage2);
			System.out.println("Distance after stage1: " + dist);
		}
		
		for(int i = 0; i< speedTree.size(); i++){
			double height = speedTree.get(i).getHeight();
			speedTree.get(i).setHeight(height*(1-minTime));
		}
		System.out.println("That speedTree: " + speedTree);
		//Stage2:
		speedTree = modifiedSpeedTree(treeStage2, tree2, 10, 6, t3Move, speedTree);	
		tree2Mod = tree2Mod(treeStage2, speedTree);
		
		//tree2Ordered = tree2Ordered(treeStage2, speedTree);
		timeSwapTree = timeSwapTree(treeStage2, tree2Mod);
		minTime = findMinTime(timeSwapTree);
		if(minTime == 1.0){
			return 100000;
		}
		ArrayList<tNode> treeStage3 = getTreeAtTime(treeStage2, speedTree, minTime);
		dist = findDistance(treeStage2, treeStage3);
		distance += dist;
		
		
		if(output){
			System.out.println("Speed Tree: 	" + speedTree);
			System.out.println("Tree to reach:  " + tree2Mod);
			System.out.println("Tree End stage 2:" + treeStage3);	
			System.out.println("Distance after stage2: " + dist);
		}
		//stage3:  	
		for(int i = 0; i< speedTree.size(); i++){
			double height = speedTree.get(i).getHeight();
			speedTree.get(i).setHeight(height*(1-minTime));
		}
		System.out.println("That speedTree: " + speedTree);
		
		
		
		timeSwapTree = timeSwapTree(treeStage3, tree2Mod);
		minTime = findMinTime(timeSwapTree);
		if(minTime == 1.0){
			return 100000;
		}
		ArrayList<tNode> treeStage4 = getTreeAtTime(treeStage3, speedTree, minTime);
		dist = findDistance(treeStage3, treeStage4);
		distance += dist;
		
		if(output){
			System.out.println("Tree End stage3: " + treeStage4);
			System.out.println("Distance after stage3: " + dist);			
		}
		 //stage4:  only need distance;
	
		dist = findDistance(treeStage4, tree2);
		distance += dist;
		
		if(output){
			System.out.println("End tree: " + tree2);
			System.out.println("Distance after stage4: " + dist);	
			System.out.println("Total Distance: " + distance);
		}
		return distance;
	}
	public static ArrayList<tNode> modifiedGetTreeAtTime(ArrayList<tNode> tree, ArrayList<tNode> speedTree, double minTime){
		ArrayList<tNode> treeAtTime = new ArrayList<tNode>();
		ArrayList<tNode> intermediateTree = new ArrayList<tNode>();
		String currentTaxa = "";
		int speedIndex = 0;
		for(tNode n : tree){
			for(String s : n.taxa){
				if(currentTaxa.indexOf(s) == -1){
					currentTaxa += s;
					ArrayList<String> taxa = new ArrayList<String>();
					taxa.add(s);
					double height = n.getHeight() + speedTree.get(speedIndex).getHeight()*minTime;
					intermediateTree.add(new tNode(taxa, height));					
				}
			}
			speedIndex++;
		}		
		for(int i = 0; i< tree.size(); i++){
			double height = tree.get(i).getHeight() + (speedTree.get(i).getHeight() * minTime);
			treeAtTime.add(new tNode(tree.get(i).getTaxa(),height )); //can sort out the taxa in the node later
		}		
		return treeAtTime;
	}
	
	public static ArrayList<tNode> tree2Mod(ArrayList<tNode> tree1, ArrayList<tNode> speedTree){
		ArrayList<tNode> tree2 = new ArrayList<tNode>();
		for(int i = 0; i<tree1.size() ; i++){
			double height = tree1.get(i).getHeight() + speedTree.get(i).getHeight();
			tree2.add(new tNode(tree1.get(i).getTaxa(), height ));
		}		
		return tree2;
	}
	public static ArrayList<tNode> reorderTree2(ArrayList<tNode> tree){
		tree.add(tree.get(1));
		tree.add(tree.get(0));
		tree.add(tree.get(2));
		tree.remove(2);
		tree.remove(1);
		tree.remove(0);
		return tree;	
	}
	
	//generate minTime 
	public static double findMinTime(ArrayList<tNode> timeSwapTree){
		double minTime = 1.0;
		for(int i = 0 ; i<timeSwapTree.size(); i++){
			double nextTime = timeSwapTree.get(i).getHeight();
			if(nextTime < minTime && nextTime > 0.0000000001){
				minTime = nextTime;
			}
		}		
		return minTime;
	}
	
	//generate tree2Ordered
	public static ArrayList<tNode> tree2Ordered(ArrayList<tNode> tree1, ArrayList<tNode> speedTree){
		ArrayList<tNode> tree2Ordered = new ArrayList<tNode>();
		for(int i=0; i<tree1.size(); i++){
			double h = tree1.get(i).getHeight() + speedTree.get(i).getHeight();
			tree2Ordered.add(new tNode(tree1.get(i).getTaxa(), h));
		}	
		return tree2Ordered;
	}
	
	
	//uses modified speedTree (just for the 3 nodes);
	public static ArrayList<tNode> modifiedSpeedTree(ArrayList<tNode> tree1, ArrayList<tNode> tree2, int t1Move, int t2Move, int t3Move, ArrayList<tNode> oldSpeed){
		ArrayList<tNode> speedTree = new ArrayList<tNode>();
		double t1Speed = 0, t2Speed = 0, t3Speed = 0;
		double t1 = tree1.get(0).getHeight();
		double t2 = tree1.get(1).getHeight();
		double t3 = tree1.get(2).getHeight();
		double t1Dash = tree2.get(0).getHeight();
		double t2Dash = tree2.get(1).getHeight();
		double t3Dash = tree2.get(2).getHeight();
		switch (t1Move) {
		case 0: //t1 -> t3'
			t1Speed = t3Dash - t1;
			break;
		case 1: //t1 -> t1'
			t1Speed = t1Dash - t1;
			break;
		case 2:  //t1 -> t3'+t1'/2
			t1Speed = ((t3Dash + t1Dash)/2.0) - t1; 
			break;
		case 3: //t1 -> absMax(t3'-t1,t2'-t1)
			if(Math.abs(t3Dash - t1) > Math.abs(t1Dash -t1)){
				t1Speed = t3Dash - t1;
			} else {
				t1Speed = t1Dash - t1;
			}
			break;
		case 4:  //t1 - > min
			if(Math.abs(t3Dash - t1) <= Math.abs(t1Dash - t1)){
				if(Math.abs(t3Dash -t1) <= Math.abs((t3Dash + t1Dash)/2.0 - t1)){
					t1Speed = t3Dash - t1;
				} else {
					t1Speed = (t3Dash + t1Dash)/2.0 - t1; 
				}				
			}else {
				if(Math.abs(t1Dash - t1) <= Math.abs((t3Dash + t1Dash)/2.0 - t1)){
					t1Speed = t1Dash - t1;
				} else {
					t1Speed = (t3Dash + t1Dash)/2.0 - t1;
				}
			}
			break;
		default : 
			t1Speed = oldSpeed.get(0).getHeight();
			break;
		}	
		
		switch (t2Move){
		case 0:
			t2Speed = t3Dash - t2;
			break;
		case 1: //Stage1
			t2Speed = t1Dash - t2;
			break;
		case 2: 
			t2Speed = (t3Dash + t1Dash)/2.0 - t2;
			break;
		case 3:
			if(Math.abs(t3Dash - t2) >= Math.abs(t1Dash - t3)){
				t2Speed = t3Dash - t2;
			} else {
				t2Speed = t1Dash - t2;
			}
			break;
		case 4:
			if(Math.abs(t3Dash - t2) <= Math.abs(t1Dash - t2)){
				if(Math.abs(t3Dash - t2) <= Math.abs((t3Dash+t1Dash)/2.0 - t2)){
					t2Speed = t3Dash - t2;
				} else {
					t2Speed = (t3Dash + t1Dash)/2.0 - t2;
				}
			} else {
				if(Math.abs(t1Dash - t2) <= Math.abs((t1Dash+t3Dash)/2.0 - t2)){
					t2Speed = t1Dash - t2;
				}else {
					t2Speed = (t1Dash + t3Dash)/2.0 - t2;
				}
			}
			break;
		case 5:  //t2 -> t2; Stage1
			t2Speed = 0.0;
			break;
		case 6: //Stage2  t2 -> t1'
			t2Speed = t2Dash - t2;
			break;
		default:
			t2Speed = oldSpeed.get(1).getHeight();
			break;
		}		
		switch (t3Move){
		
			//stage2 : ->
		case 0: // t3 -> t3'
			t3Speed = t3Dash - t3;
			break;
		case 1: //t3 -> t2'
			t3Speed = t1Dash - t3;
			break;
		case 2: //t3 -> t3'+t2'/2
			t3Speed = ((t3Dash + t1Dash)/2.0) - t3;
			break;
		case 3: //t3 - >  max(of abs case 0-1, I don't believe case2 can ever be greater than 0 or 1)
			if(Math.abs(t3Dash - t3) >= Math.abs(t1Dash -t3)){
				t3Speed = t3Dash - t3;
			} else {
				t3Speed = t1Dash - t3;
			}			
			break;
		case 4: //t3 --> min( of abs case 0-2) Here case2 can be less than 0 and 1
			if(Math.abs(t3Dash - t3) <= Math.abs(t1Dash - t3)){
				if(Math.abs(t3Dash -t3) <= Math.abs((t3Dash + t1Dash)/2.0 - t3)){
					t3Speed = t3Dash - t3;
				} else {
					t3Speed = (t3Dash + t1Dash)/2.0 - t3; 
				}				
			}else {
				if(Math.abs(t1Dash - t3) <= Math.abs((t3Dash + t1Dash)/2.0 - t3)){
					t3Speed = t1Dash - t3;
				} else {
					t3Speed = (t3Dash + t1Dash)/2.0 - t3;
				}
			}
			break;
		case 5: //t3 -> t1'; Stage1
			t3Speed = t2Dash - t3;
			break;
		default: 
			t3Speed = oldSpeed.get(2).getHeight();
			break;
		}
		
		speedTree.add(new tNode(tree1.get(0).getTaxa(), t1Speed));
		speedTree.add(new tNode(tree1.get(1).getTaxa(), t2Speed));
		speedTree.add(new tNode(tree1.get(2).getTaxa(), t3Speed));
			
		return speedTree;
	}
}
