package tTree;

import java.util.ArrayList;
import java.util.Stack;
//Takes newickformat string and converts it into a tree (ArrayList<tNode>)
public class TreeFromNewick {
	ArrayList<tNode> tree;
	
	public TreeFromNewick(String nf){
		tree = useAStack(nf);
	}
	
	public ArrayList<tNode> getTree(){
		return tree;
	}
	
	private ArrayList<tNode> useAStack(String nf){
		Stack<String> s = new Stack<String>();		
		Stack<String> holder = new Stack<String>();
		ArrayList<tNode> tree = new ArrayList<tNode>();
		for(int i = 0; i < nf.length(); i++){	
			String next =  nf.charAt(i) + "";
			if(!next.matches("[(),:]")){ //then it's a number/string
				int minIndex = findMinIndex(nf, i);
				//System.out.println(minIndex);
				next = nf.substring(i, minIndex);
				s.push(next);			
				i = minIndex-1;
			}
			else if(next.equals(")")){
				//create a node;
				int numCloseBrackets = 1;
				holder.push(")");
				while(numCloseBrackets != 0){
					String piece = s.pop();					
					if(piece.equals("(")){
						numCloseBrackets--;
					} else if(piece.equals(")")){
						numCloseBrackets++;
					}
					holder.push(piece);										
				}					
				//go through holder, get all the bits which are not :,() and if you can't parse them as doubles they are the taxa.
				//double heightOfThisNode = 0;
				ArrayList<String> taxa = new ArrayList<String>();
				//int numOpenBrackets = 0;
				while (!holder.isEmpty()) {
					
					String bit = holder.pop();
					if(bit.matches("[a-zA-Z]+")){	
						//it's a taxa;
						taxa.add(bit);		
					}					
					s.push(bit);
				}							
				
				boolean notComplete = true;
				double totalHeight = 0;
				totalHeight += Double.parseDouble(s.get(s.size()-2));
				int counter = 4;
				while(notComplete){
					if(s.get(s.size()-counter).equals(")")){
						//still need to add more
						totalHeight += Double.parseDouble(s.get(s.size()-(counter+1)));
						counter += 3;
					} else {		
						notComplete = false;
					}
				}				
				
				tree.add(new tNode(taxa, totalHeight));
				//put holder back in the stack.			
				
			} else {
				s.push(next);
			}			
		}	
		return tree;
	}
	
	private int findMinIndex(String nf, int i){
		int minIndex = 0;
		
		int indexOpen = nf.indexOf('(',i);
		int indexClose = nf.indexOf(')',i);
		int indexComma = nf.indexOf(',',i);
		int indexColon = nf.indexOf(':',i);
		int indexBracket = 0;
		if(indexOpen > 0 && indexClose > 0){
			indexBracket = Math.min(indexOpen,indexClose);
		} else {
			indexBracket = Math.max(indexOpen,indexClose);
		}
		int indexOther = 0;
		if(indexComma > 0 && indexColon > 0){
			indexOther = Math.min(indexComma, indexColon);
		} else {
			indexOther = Math.max(indexComma, indexColon);
		}
		
		if(indexBracket > 0 && indexOther > 0){
			minIndex = Math.min(indexBracket,  indexOther);
		} else {
			minIndex = Math.max(indexBracket,  indexOther);
		}
		return minIndex;
	}
	
	
	
}
